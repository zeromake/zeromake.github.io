{"title":"Android的aidl相互通信机制","date":"2016-01-03T13:42:01.000Z","tags":["Android","aidl","IBind"],"filename":"Android-aidl","body":"<h2><a class=\"anchor\" name=\"service使用aidl的与activity相互交互\" href=\"#service使用aidl的与activity相互交互\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Service使用aidl的与Activity相互交互</h2><h4><a class=\"anchor\" name=\"一、为什么要使用aidl\" href=\"#一、为什么要使用aidl\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>一、为什么要使用aidl</h4><p>原因是当我们的Client和Service不是同一个进程时是无法直接使用的，而在android中进程间通讯的方法有Activity、Content Provider、Broadcast和Service。\n其中Activity需要界面，隐式调用没有回调Broadcast的接收对象经常会重新被实例化，且以上两种都是通过intent传送。回调不能完成交互。\nContent Provider则只提供数据，Service有aidl这门进程间调用函数的机制。\n<!--more--></p>\n<h3><a class=\"anchor\" name=\"二、普通单向aidl使用\" href=\"#二、普通单向aidl使用\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>二、普通单向aidl使用</h3><p>需要一个Client和Service以及aidl接口，其中Client和Service是可以不在同一个应用中的。下面是aidl：IMyAidl.aidl</p>\n<pre class=\"code java\"><code class=\"java\">    <span class=\"hljs-keyword\">package</span> zero.aidldemo.aidl;\n\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">IMyAidl</span> </span>{\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">(String str)</span></span>;\n    }\n</code></pre>\n<p>以上写完会在gen下同包名中生成与aidl文件相同的java文件打开后这个类中有一个抽象内部类Stub实现Binder和自身我们在Service中写一个继承这个Stub的内部类\nService：ServiceMain.java 把当前Service的class全名作为Action注册以便于其他进程调用。</p>\n<pre class=\"code java\"><code class=\"java\">\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ServiceMain</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Service</span></span>{\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">static</span> String SERVICE_CLASS_NAME = <span class=\"hljs-string\">\"zero.musicplay.service.ServiceMain\"</span>;\n            <span class=\"hljs-comment\">//继承IMyAidl.Stub</span>\n            <span class=\"hljs-keyword\">private</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyAidl</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">IMyAidl</span>.<span class=\"hljs-title\">Stub</span></span>{\n                <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">(String str)</span> <span class=\"hljs-keyword\">throws</span> RemoteException </span>{\n                Log.i(<span class=\"hljs-string\">\"zerolog\"</span>,<span class=\"hljs-string\">\"ServiceMain_MyAidl_show=\"</span>+str);\n            }\n            }\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> IBinder <span class=\"hljs-title\">onBind</span><span class=\"hljs-params\">(Intent intent)</span> </span>{\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> ServiceBinder();\n        }\n    }\n</code></pre>\n<p>Client用一个Activity来实现:ActivityClient.java</p>\n<pre class=\"code java\"><code class=\"java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ActivityClient</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Activity</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">OnClickListener</span>,<span class=\"hljs-title\">ServiceConnection</span></span>{\n    <span class=\"hljs-comment\">//bind后的接口实现对象。</span>\n    <span class=\"hljs-keyword\">private</span> IMyAidl mAsInterface;\n    <span class=\"hljs-comment\">//Service的Intent</span>\n    <span class=\"hljs-keyword\">private</span> Intent _intent;\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onCreate</span><span class=\"hljs-params\">(Bundle savedInstanceState)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>.onCreate(savedInstanceState);\n        <span class=\"hljs-comment\">//界面加载和一个按键监听。。。</span>\n        setContentView(R.layout.activity_main);\n        findViewById(R.id.btn1).setOnClickListener(<span class=\"hljs-keyword\">this</span>);\n        <span class=\"hljs-comment\">//绑定Service</span>\n        Intent _intent=<span class=\"hljs-keyword\">new</span> Intent();\n        _intent.setAction(ServiceMain.SERVICE_CLASS_NAME);\n        <span class=\"hljs-comment\">//在4.多后具体哪个版本不记得了隐式bindService需要设置Service的包名。</span>\n        _intent.setPackage(getPackageName());\n        <span class=\"hljs-comment\">//不知道是怎么回事现在我用api23编的如果不先startService就没法bindService不知道为什么。</span>\n        <span class=\"hljs-comment\">//statrtService(_intent);</span>\n        <span class=\"hljs-comment\">//第一个Intent，ServiceConnection对象，flags自己查api吧没懂什么用。</span>\n        bindService(_intent, <span class=\"hljs-keyword\">this</span>, <span class=\"hljs-number\">0</span>);\n    }\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onClick</span><span class=\"hljs-params\">(View v)</span> </span>{\n        <span class=\"hljs-comment\">//bind是异步的防止mAsInterface还未获得而FC</span>\n        <span class=\"hljs-keyword\">if</span> (mAsInterface != <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">try</span> {\n                mAsInterface.show(<span class=\"hljs-string\">\"MainActivity-&gt;show\"</span>);\n            } <span class=\"hljs-keyword\">catch</span> (RemoteException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onDestroy</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">//记得解绑</span>\n        <span class=\"hljs-keyword\">if</span>(mAsInterface != <span class=\"hljs-keyword\">null</span>){\n            unbindService(<span class=\"hljs-keyword\">this</span>);\n            stopService(_intent);\n        }\n        <span class=\"hljs-keyword\">super</span>.onDestroy();\n    }\n        <span class=\"hljs-meta\">@Override</span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onServiceConnected</span><span class=\"hljs-params\">(ComponentName name, IBinder service)</span> </span>{\n            mAsInterface = IMyAidl.Stub.asInterface(service);\n        }\n\n        <span class=\"hljs-meta\">@Override</span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onServiceDisconnected</span><span class=\"hljs-params\">(ComponentName name)</span> </span>{\n        }\n}\n</code></pre>\n<p>效果就是点击按钮触发Service里的实现接口函数。</p>\n<h3><a class=\"anchor\" name=\"三、双向aidl使用\" href=\"#三、双向aidl使用\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>三、双向aidl使用</h3><p>单向的aidl接口中函数也可以有返回值，但是只适用于同步且时间较短。如果需要的函数执行的是一个异步任务就不好用了。\n所以这里用双向aidl比较合适。</p>\n<p>与上面相比多了一个aidl的回调先看回调的aidl:IMyAidlCallBack.aidl</p>\n<pre class=\"code java\"><code class=\"java\">    <span class=\"hljs-keyword\">package</span> zero.aidldemo.aidl;\n\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">IMyAidlCallBack</span> </span>{\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">callBackShow</span><span class=\"hljs-params\">()</span></span>;\n    }\n</code></pre>\n<p>没什么变化但是在原来的调用Service的aidl中需要加入两个方法:IMyAidl.aidl方法名不是固定的</p>\n<pre class=\"code java\"><code class=\"java\"><span class=\"hljs-keyword\">package</span> zero.aidldemo.aidl;\n<span class=\"hljs-comment\">//eclipse对aidl文件编辑支持比较差有时无法自动导包。</span>\n<span class=\"hljs-keyword\">import</span> zero.aidldemo.aidl.IMyAidlCallBack;\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">IMyAidl</span> </span>{\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">(String str)</span></span>;\n    <span class=\"hljs-comment\">//注册回调</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">registerCallback</span><span class=\"hljs-params\">(IMyAidlCallBack cb)</span></span>;\n    <span class=\"hljs-comment\">//解除回调</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">unregisterCallback</span><span class=\"hljs-params\">(IMyAidlCallBack cb)</span></span>;\n}\n</code></pre>\n<p>Service：ServiceMain.java </p>\n<pre class=\"code java\"><code class=\"java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ServiceMain</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Service</span> </span>{\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">static</span> String SERVICE_CLASS_NAME = <span class=\"hljs-string\">\"zero.musicplay.service.ServiceMain\"</span>;\n    <span class=\"hljs-comment\">// 回调列表对象</span>\n    <span class=\"hljs-keyword\">private</span> RemoteCallbackList&lt;IMyAidlCallBack&gt; mCallbackList;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyAidl</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">IMyAidl</span>.<span class=\"hljs-title\">Stub</span> </span>{\n        <span class=\"hljs-meta\">@Override</span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">show</span><span class=\"hljs-params\">(String str)</span> <span class=\"hljs-keyword\">throws</span> RemoteException </span>{\n            Log.i(<span class=\"hljs-string\">\"zerolog\"</span>, <span class=\"hljs-string\">\"ServiceMain_MyAidl_show=\"</span> + str);\n            <span class=\"hljs-comment\">// 取出已绑定的回调对象个数并开始广播</span>\n            <span class=\"hljs-keyword\">int</span> conut = mCallbackList.beginBroadcast();\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; conut; j++) {\n                <span class=\"hljs-comment\">// 遍历调用回调方法。</span>\n                mCallbackList.getBroadcastItem(j).callBackShow();\n            }\n            <span class=\"hljs-comment\">// 解除回调广播。</span>\n            mCallbackList.finishBroadcast();\n        }\n\n        <span class=\"hljs-meta\">@Override</span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">registerCallback</span><span class=\"hljs-params\">(IMyAidlCallBack cb)</span> <span class=\"hljs-keyword\">throws</span> RemoteException </span>{\n            <span class=\"hljs-comment\">// 添加到回调列表中</span>\n            mCallbackList.register(cb);\n        }\n\n        <span class=\"hljs-meta\">@Override</span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">unregisterCallback</span><span class=\"hljs-params\">(IMyAidlCallBack cb)</span>\n                <span class=\"hljs-keyword\">throws</span> RemoteException </span>{\n            <span class=\"hljs-comment\">// 从回调列表中移除</span>\n            mCallbackList.unregister(cb);\n        }\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onCreate</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// 在服务被创建时实例化一个为空的回调列表对象</span>\n        mCallbackList = <span class=\"hljs-keyword\">new</span> RemoteCallbackList&lt;IMyAidlCallBack&gt;();\n        <span class=\"hljs-keyword\">super</span>.onCreate();\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> IBinder <span class=\"hljs-title\">onBind</span><span class=\"hljs-params\">(Intent intent)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> MyAidl();\n    }\n}\n</code></pre>\n<p>和上面说的一样在原有的aidl中添加两个方法用于给回调列表对象添加删除。并需要一个回调列表对象。\n所以我在onCreate()实例化。</p>\n<p>然后是Client:ActivityClient.java</p>\n<pre class=\"code java\"><code class=\"java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ActivityClient</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Activity</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">OnClickListener</span>,\n        <span class=\"hljs-title\">ServiceConnection</span> </span>{\n    <span class=\"hljs-comment\">// bind后的接口实现对象。</span>\n    <span class=\"hljs-keyword\">private</span> IMyAidl mAsInterface;\n    <span class=\"hljs-comment\">// Service的Intent</span>\n    <span class=\"hljs-keyword\">private</span> Intent _intent;\n    <span class=\"hljs-comment\">// 回调实现对象</span>\n    <span class=\"hljs-keyword\">private</span> MyCallBack mCallBack;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onCreate</span><span class=\"hljs-params\">(Bundle savedInstanceState)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>.onCreate(savedInstanceState);\n        <span class=\"hljs-comment\">// 界面加载和一个按键监听。。。</span>\n        setContentView(R.layout.activity_main);\n        findViewById(R.id.btn1).setOnClickListener(<span class=\"hljs-keyword\">this</span>);\n        <span class=\"hljs-comment\">// 实例化回调实现</span>\n        mCallBack = <span class=\"hljs-keyword\">new</span> MyCallBack();\n        <span class=\"hljs-comment\">// 绑定Service</span>\n        Intent _intent = <span class=\"hljs-keyword\">new</span> Intent();\n        _intent.setAction(ServiceMain.SERVICE_CLASS_NAME);\n        <span class=\"hljs-comment\">// 在4.+后具体哪个版本不记得了隐式bindService需要设置Service的包名。</span>\n        _intent.setPackage(getPackageName());\n        <span class=\"hljs-comment\">// 不知道是怎么回事现在我用api23编的如果不先startService就没法bindService不知道为什么。</span>\n        <span class=\"hljs-comment\">// statrtService(_intent);</span>\n        <span class=\"hljs-comment\">// 第一个Intent，ServiceConnection对象，flags自己查api吧没懂什么用。</span>\n        bindService(_intent, <span class=\"hljs-keyword\">this</span>, <span class=\"hljs-number\">0</span>);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onClick</span><span class=\"hljs-params\">(View v)</span> </span>{\n        <span class=\"hljs-comment\">// bind是异步的防止mAsInterface还未获得而FC</span>\n        <span class=\"hljs-keyword\">if</span> (mAsInterface != <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">try</span> {\n                mAsInterface.show(<span class=\"hljs-string\">\"MainActivity-&gt;show\"</span>);\n            } <span class=\"hljs-keyword\">catch</span> (RemoteException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onDestroy</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// 记得解绑</span>\n        <span class=\"hljs-keyword\">if</span> (mAsInterface != <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">try</span> {\n                mAsInterface.unregisterCallback(mCallBack);\n            } <span class=\"hljs-keyword\">catch</span> (RemoteException e) {\n                <span class=\"hljs-comment\">// TODO Auto-generated catch block</span>\n                e.printStackTrace();\n            }\n            unbindService(<span class=\"hljs-keyword\">this</span>);\n            stopService(_intent);\n        }\n        <span class=\"hljs-keyword\">super</span>.onDestroy();\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onServiceConnected</span><span class=\"hljs-params\">(ComponentName name, IBinder service)</span> </span>{\n        mAsInterface = IMyAidl.Stub.asInterface(service);\n        <span class=\"hljs-comment\">// 在绑定完成后将通过定义好的方法添加到Service的回调列表中</span>\n        <span class=\"hljs-keyword\">try</span> {\n            mAsInterface.registerCallback(mCallBack);\n        } <span class=\"hljs-keyword\">catch</span> (RemoteException e) {\n            <span class=\"hljs-comment\">// TODO Auto-generated catch block</span>\n            e.printStackTrace();\n        }\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onServiceDisconnected</span><span class=\"hljs-params\">(ComponentName name)</span> </span>{\n    }\n\n    <span class=\"hljs-comment\">// 实现回调接口中的方法。</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyCallBack</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">IMyAidlCallBack</span>.<span class=\"hljs-title\">Stub</span> </span>{\n\n        <span class=\"hljs-meta\">@Override</span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">callBackShow</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> RemoteException </span>{\n            Log.i(<span class=\"hljs-string\">\"zerolog\"</span>, <span class=\"hljs-string\">\"callBackShow\"</span>);\n            <span class=\"hljs-comment\">// 千万记住不能在这里再调用Service的aidl方法会报异常</span>\n            <span class=\"hljs-comment\">// java.lang.IllegalStateException: beginBroadcast() called while</span>\n            <span class=\"hljs-comment\">// already in a broadcast</span>\n            <span class=\"hljs-comment\">// mAsInterface.show(\"\");</span>\n        }\n\n    }\n}\n</code></pre>\n<p>好了以上就是一个交互式的aidl小例子，回调可以在Service的任意地方调用不一定要在Service的aidl被调用时调用。\n以及这些内部类也都可以提取出来，但是就不好访问Service和视图了。</p>\n<h3><a class=\"anchor\" name=\"四、注意\" href=\"#四、注意\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>四、注意</h3><pre class=\"code bash\"><code class=\"bash\">1.回调对象的实现方法不能直接调用Service的aidl方法。可以用Handler来调用。\n2.如果发觉只用<span class=\"hljs-built_in\">bind</span>Srevice无法启动Service可以先startService再<span class=\"hljs-built_in\">bind</span>Srevice\n</code></pre>\n<h3><a class=\"anchor\" name=\"五、例子源码\" href=\"#五、例子源码\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>五、例子源码</h3><p><a href=\"http://pan.baidu.com/s/1mh1fO4S\">度盘</a></p>\n"}