<!doctype html>
<html lang="zh">
<head>
	
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta http-equiv="Content-Language" content="zh">
	<meta name="viewport" content="width=device-width">
	<title>Android的aidl相互通信机制-zeromake static blog</title>
	<link rel="stylesheet" href="/static/css/markdownpad-github.css" type="text/css">
	<link rel="stylesheet" href="/static/css/base.css" type="text/css">
	
	<link rel="stylesheet" href="/css/pygments.css">
	<script type="text/javascript">
		var duoshuoQuery = {short_name:"fly-zero"};
	</script>
	<script src="//static.duoshuo.com/embed.js" charset="utf-8"></script>

	
</head>

<body>
	<header class="base_header">
		<h1><a href="/">zeromake blog</a></h1>
		<div class="author-info">
			<a class="author-info-github" href="https://github.com/zeromake">GitHub</a>
			<a class="author-info-sf" href="https://segmentfault.com/u/zeromake">SegmentFault</a>
		</div>
	</header>
	<div class="zero_content">
		<div class="markdown-content">
			
	<h2>Android的aidl相互通信机制</h2>
	<div class="markdown-body">
		<div>创建时间: 2016-01-03 13:42:01</div>
		<div>最后更新: </div>
		<div>博客原文:<a href="http://blog.zeromake.com/pages/Android的aidl相互通信机制/">地址</a></div>
		<hr>
		<h2 id="serviceaidlactivity"><a name="user-content-serviceaidlactivity" href="#serviceaidlactivity" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>Service使用aidl的与Activity相互交互</h2>
<h4 id="aidl"><a name="user-content-aidl" href="#aidl" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>一、为什么要使用aidl</h4>
<p>原因是当我们的Client和Service不是同一个进程时是无法直接使用的，而在android中进程间通讯的方法有Activity、Content Provider、Broadcast和Service。<br />
其中Activity需要界面，隐式调用没有回调Broadcast的接收对象经常会重新被实例化，且以上两种都是通过intent传送。回调不能完成交互。<br />
Content Provider则只提供数据，Service有aidl这门进程间调用函数的机制。<br />
<!--more--></p>
<h3 id="aidl_1"><a name="user-content-aidl_1" href="#aidl_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>二、普通单向aidl使用</h3>
<p>需要一个Client和Service以及aidl接口，其中Client和Service是可以不在同一个应用中的。下面是aidl：IMyAidl.aidl<br />
<div class="codehilite"><pre><span></span>    <span class="kn">package</span> <span class="nn">zero.aidldemo.aidl</span><span class="o">;</span>

    <span class="kd">interface</span> <span class="nc">IMyAidl</span> <span class="o">{</span>
        <span class="kt">void</span> <span class="nf">show</span><span class="o">(</span><span class="n">String</span> <span class="n">str</span><span class="o">);</span>
    <span class="o">}</span>
</pre></div>
<br />
以上写完会在gen下同包名中生成与aidl文件相同的java文件打开后这个类中有一个抽象内部类Stub实现Binder和自身我们在Service中写一个继承这个Stub的内部类<br />
Service：ServiceMain.java 把当前Service的class全名作为Action注册以便于其他进程调用。<br />
<div class="codehilite"><pre><span></span>    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">ServiceMain</span> <span class="kd">extends</span> <span class="n">Service</span><span class="o">{</span>
        <span class="kd">public</span> <span class="kd">final</span> <span class="kd">static</span> <span class="n">String</span> <span class="n">SERVICE_CLASS_NAME</span> <span class="o">=</span> <span class="s">&quot;zero.musicplay.service.ServiceMain&quot;</span><span class="o">;</span>
            <span class="c1">//继承IMyAidl.Stub</span>
            <span class="kd">private</span> <span class="kd">class</span> <span class="nc">MyAidl</span> <span class="kd">extends</span> <span class="n">IMyAidl</span><span class="o">.</span><span class="na">Stub</span><span class="o">{</span>
                <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">show</span><span class="o">(</span><span class="n">String</span> <span class="n">str</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">RemoteException</span> <span class="o">{</span>
                <span class="n">Log</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="s">&quot;zerolog&quot;</span><span class="o">,</span><span class="s">&quot;ServiceMain_MyAidl_show=&quot;</span><span class="o">+</span><span class="n">str</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="o">}</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="n">IBinder</span> <span class="nf">onBind</span><span class="o">(</span><span class="n">Intent</span> <span class="n">intent</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="n">ServiceBinder</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
</pre></div>
</p>
<p>Client用一个Activity来实现:ActivityClient.java<br />
<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ActivityClient</span> <span class="kd">extends</span> <span class="n">Activity</span> <span class="kd">implements</span> <span class="n">OnClickListener</span><span class="o">,</span><span class="n">ServiceConnection</span><span class="o">{</span>
    <span class="c1">//bind后的接口实现对象。</span>
    <span class="kd">private</span> <span class="n">IMyAidl</span> <span class="n">mAsInterface</span><span class="o">;</span>
    <span class="c1">//Service的Intent</span>
    <span class="kd">private</span> <span class="n">Intent</span> <span class="n">_intent</span><span class="o">;</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
        <span class="c1">//界面加载和一个按键监听。。。</span>
        <span class="n">setContentView</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">activity_main</span><span class="o">);</span>
        <span class="n">findViewById</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">btn1</span><span class="o">).</span><span class="na">setOnClickListener</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="c1">//绑定Service</span>
        <span class="n">Intent</span> <span class="n">_intent</span><span class="o">=</span><span class="k">new</span> <span class="n">Intent</span><span class="o">();</span>
        <span class="n">_intent</span><span class="o">.</span><span class="na">setAction</span><span class="o">(</span><span class="n">ServiceMain</span><span class="o">.</span><span class="na">SERVICE_CLASS_NAME</span><span class="o">);</span>
        <span class="c1">//在4.多后具体哪个版本不记得了隐式bindService需要设置Service的包名。</span>
        <span class="n">_intent</span><span class="o">.</span><span class="na">setPackage</span><span class="o">(</span><span class="n">getPackageName</span><span class="o">());</span>
        <span class="c1">//不知道是怎么回事现在我用api23编的如果不先startService就没法bindService不知道为什么。</span>
        <span class="c1">//statrtService(_intent);</span>
        <span class="c1">//第一个Intent，ServiceConnection对象，flags自己查api吧没懂什么用。</span>
        <span class="n">bindService</span><span class="o">(</span><span class="n">_intent</span><span class="o">,</span> <span class="k">this</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onClick</span><span class="o">(</span><span class="n">View</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//bind是异步的防止mAsInterface还未获得而FC</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">mAsInterface</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">mAsInterface</span><span class="o">.</span><span class="na">show</span><span class="o">(</span><span class="s">&quot;MainActivity-&gt;show&quot;</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">RemoteException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onDestroy</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//记得解绑</span>
        <span class="k">if</span><span class="o">(</span><span class="n">mAsInterface</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">){</span>
            <span class="n">unbindService</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
            <span class="n">stopService</span><span class="o">(</span><span class="n">_intent</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onDestroy</span><span class="o">();</span>
    <span class="o">}</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onServiceConnected</span><span class="o">(</span><span class="n">ComponentName</span> <span class="n">name</span><span class="o">,</span> <span class="n">IBinder</span> <span class="n">service</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">mAsInterface</span> <span class="o">=</span> <span class="n">IMyAidl</span><span class="o">.</span><span class="na">Stub</span><span class="o">.</span><span class="na">asInterface</span><span class="o">(</span><span class="n">service</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onServiceDisconnected</span><span class="o">(</span><span class="n">ComponentName</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<br />
效果就是点击按钮触发Service里的实现接口函数。</p>
<h3 id="aidl_2"><a name="user-content-aidl_2" href="#aidl_2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>三、双向aidl使用</h3>
<p>单向的aidl接口中函数也可以有返回值，但是只适用于同步且时间较短。如果需要的函数执行的是一个异步任务就不好用了。<br />
所以这里用双向aidl比较合适。</p>
<p>与上面相比多了一个aidl的回调先看回调的aidl:IMyAidlCallBack.aidl<br />
<div class="codehilite"><pre><span></span>    <span class="kn">package</span> <span class="nn">zero.aidldemo.aidl</span><span class="o">;</span>

    <span class="kd">interface</span> <span class="nc">IMyAidlCallBack</span> <span class="o">{</span>
        <span class="kt">void</span> <span class="nf">callBackShow</span><span class="o">();</span>
    <span class="o">}</span>
</pre></div>
<br />
没什么变化但是在原来的调用Service的aidl中需要加入两个方法:IMyAidl.aidl方法名不是固定的<br />
<div class="codehilite"><pre><span></span><span class="kn">package</span> <span class="nn">zero.aidldemo.aidl</span><span class="o">;</span>
<span class="c1">//eclipse对aidl文件编辑支持比较差有时无法自动导包。</span>
<span class="kn">import</span> <span class="nn">zero.aidldemo.aidl.IMyAidlCallBack</span><span class="o">;</span>
<span class="kd">interface</span> <span class="nc">IMyAidl</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">show</span><span class="o">(</span><span class="n">String</span> <span class="n">str</span><span class="o">);</span>
    <span class="c1">//注册回调</span>
    <span class="kt">void</span> <span class="nf">registerCallback</span><span class="o">(</span><span class="n">IMyAidlCallBack</span> <span class="n">cb</span><span class="o">);</span>
    <span class="c1">//解除回调</span>
    <span class="kt">void</span> <span class="nf">unregisterCallback</span><span class="o">(</span><span class="n">IMyAidlCallBack</span> <span class="n">cb</span><span class="o">);</span>
<span class="o">}</span>
</pre></div>
<br />
Service：ServiceMain.java <br />
<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ServiceMain</span> <span class="kd">extends</span> <span class="n">Service</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kd">static</span> <span class="n">String</span> <span class="n">SERVICE_CLASS_NAME</span> <span class="o">=</span> <span class="s">&quot;zero.musicplay.service.ServiceMain&quot;</span><span class="o">;</span>
    <span class="c1">// 回调列表对象</span>
    <span class="kd">private</span> <span class="n">RemoteCallbackList</span><span class="o">&lt;</span><span class="n">IMyAidlCallBack</span><span class="o">&gt;</span> <span class="n">mCallbackList</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kd">class</span> <span class="nc">MyAidl</span> <span class="kd">extends</span> <span class="n">IMyAidl</span><span class="o">.</span><span class="na">Stub</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">show</span><span class="o">(</span><span class="n">String</span> <span class="n">str</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">RemoteException</span> <span class="o">{</span>
            <span class="n">Log</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="s">&quot;zerolog&quot;</span><span class="o">,</span> <span class="s">&quot;ServiceMain_MyAidl_show=&quot;</span> <span class="o">+</span> <span class="n">str</span><span class="o">);</span>
            <span class="c1">// 取出已绑定的回调对象个数并开始广播</span>
            <span class="kt">int</span> <span class="n">conut</span> <span class="o">=</span> <span class="n">mCallbackList</span><span class="o">.</span><span class="na">beginBroadcast</span><span class="o">();</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">conut</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="c1">// 遍历调用回调方法。</span>
                <span class="n">mCallbackList</span><span class="o">.</span><span class="na">getBroadcastItem</span><span class="o">(</span><span class="n">j</span><span class="o">).</span><span class="na">callBackShow</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="c1">// 解除回调广播。</span>
            <span class="n">mCallbackList</span><span class="o">.</span><span class="na">finishBroadcast</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">registerCallback</span><span class="o">(</span><span class="n">IMyAidlCallBack</span> <span class="n">cb</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">RemoteException</span> <span class="o">{</span>
            <span class="c1">// 添加到回调列表中</span>
            <span class="n">mCallbackList</span><span class="o">.</span><span class="na">register</span><span class="o">(</span><span class="n">cb</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">unregisterCallback</span><span class="o">(</span><span class="n">IMyAidlCallBack</span> <span class="n">cb</span><span class="o">)</span>
                <span class="kd">throws</span> <span class="n">RemoteException</span> <span class="o">{</span>
            <span class="c1">// 从回调列表中移除</span>
            <span class="n">mCallbackList</span><span class="o">.</span><span class="na">unregister</span><span class="o">(</span><span class="n">cb</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 在服务被创建时实例化一个为空的回调列表对象</span>
        <span class="n">mCallbackList</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RemoteCallbackList</span><span class="o">&lt;</span><span class="n">IMyAidlCallBack</span><span class="o">&gt;();</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="n">IBinder</span> <span class="nf">onBind</span><span class="o">(</span><span class="n">Intent</span> <span class="n">intent</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">MyAidl</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<br />
和上面说的一样在原有的aidl中添加两个方法用于给回调列表对象添加删除。并需要一个回调列表对象。<br />
所以我在onCreate()实例化。</p>
<p>然后是Client:ActivityClient.java<br />
<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ActivityClient</span> <span class="kd">extends</span> <span class="n">Activity</span> <span class="kd">implements</span> <span class="n">OnClickListener</span><span class="o">,</span>
        <span class="n">ServiceConnection</span> <span class="o">{</span>
    <span class="c1">// bind后的接口实现对象。</span>
    <span class="kd">private</span> <span class="n">IMyAidl</span> <span class="n">mAsInterface</span><span class="o">;</span>
    <span class="c1">// Service的Intent</span>
    <span class="kd">private</span> <span class="n">Intent</span> <span class="n">_intent</span><span class="o">;</span>
    <span class="c1">// 回调实现对象</span>
    <span class="kd">private</span> <span class="n">MyCallBack</span> <span class="n">mCallBack</span><span class="o">;</span>

    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle</span> <span class="n">savedInstanceState</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
        <span class="c1">// 界面加载和一个按键监听。。。</span>
        <span class="n">setContentView</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">activity_main</span><span class="o">);</span>
        <span class="n">findViewById</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">btn1</span><span class="o">).</span><span class="na">setOnClickListener</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="c1">// 实例化回调实现</span>
        <span class="n">mCallBack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyCallBack</span><span class="o">();</span>
        <span class="c1">// 绑定Service</span>
        <span class="n">Intent</span> <span class="n">_intent</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Intent</span><span class="o">();</span>
        <span class="n">_intent</span><span class="o">.</span><span class="na">setAction</span><span class="o">(</span><span class="n">ServiceMain</span><span class="o">.</span><span class="na">SERVICE_CLASS_NAME</span><span class="o">);</span>
        <span class="c1">// 在4.+后具体哪个版本不记得了隐式bindService需要设置Service的包名。</span>
        <span class="n">_intent</span><span class="o">.</span><span class="na">setPackage</span><span class="o">(</span><span class="n">getPackageName</span><span class="o">());</span>
        <span class="c1">// 不知道是怎么回事现在我用api23编的如果不先startService就没法bindService不知道为什么。</span>
        <span class="c1">// statrtService(_intent);</span>
        <span class="c1">// 第一个Intent，ServiceConnection对象，flags自己查api吧没懂什么用。</span>
        <span class="n">bindService</span><span class="o">(</span><span class="n">_intent</span><span class="o">,</span> <span class="k">this</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onClick</span><span class="o">(</span><span class="n">View</span> <span class="n">v</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// bind是异步的防止mAsInterface还未获得而FC</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">mAsInterface</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">mAsInterface</span><span class="o">.</span><span class="na">show</span><span class="o">(</span><span class="s">&quot;MainActivity-&gt;show&quot;</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">RemoteException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onDestroy</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 记得解绑</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">mAsInterface</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="n">mAsInterface</span><span class="o">.</span><span class="na">unregisterCallback</span><span class="o">(</span><span class="n">mCallBack</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">RemoteException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// TODO Auto-generated catch block</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="n">unbindService</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
            <span class="n">stopService</span><span class="o">(</span><span class="n">_intent</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onDestroy</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onServiceConnected</span><span class="o">(</span><span class="n">ComponentName</span> <span class="n">name</span><span class="o">,</span> <span class="n">IBinder</span> <span class="n">service</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">mAsInterface</span> <span class="o">=</span> <span class="n">IMyAidl</span><span class="o">.</span><span class="na">Stub</span><span class="o">.</span><span class="na">asInterface</span><span class="o">(</span><span class="n">service</span><span class="o">);</span>
        <span class="c1">// 在绑定完成后将通过定义好的方法添加到Service的回调列表中</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">mAsInterface</span><span class="o">.</span><span class="na">registerCallback</span><span class="o">(</span><span class="n">mCallBack</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">RemoteException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// TODO Auto-generated catch block</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onServiceDisconnected</span><span class="o">(</span><span class="n">ComponentName</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>

    <span class="c1">// 实现回调接口中的方法。</span>
    <span class="kd">private</span> <span class="kd">class</span> <span class="nc">MyCallBack</span> <span class="kd">extends</span> <span class="n">IMyAidlCallBack</span><span class="o">.</span><span class="na">Stub</span> <span class="o">{</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">callBackShow</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">RemoteException</span> <span class="o">{</span>
            <span class="n">Log</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="s">&quot;zerolog&quot;</span><span class="o">,</span> <span class="s">&quot;callBackShow&quot;</span><span class="o">);</span>
            <span class="c1">// 千万记住不能在这里再调用Service的aidl方法会报异常</span>
            <span class="c1">// java.lang.IllegalStateException: beginBroadcast() called while</span>
            <span class="c1">// already in a broadcast</span>
            <span class="c1">// mAsInterface.show(&quot;&quot;);</span>
        <span class="o">}</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
<br />
好了以上就是一个交互式的aidl小例子，回调可以在Service的任意地方调用不一定要在Service的aidl被调用时调用。<br />
以及这些内部类也都可以提取出来，但是就不好访问Service和视图了。</p>
<h3 id="_1"><a name="user-content-_1" href="#_1" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>四、注意</h3>
<div class="codehilite"><pre><span></span>1.回调对象的实现方法不能直接调用Service的aidl方法。可以用Handler来调用。
2.如果发觉只用bindSrevice无法启动Service可以先startService再bindSrevice
</pre></div>


<h3 id="_2"><a name="user-content-_2" href="#_2" class="headeranchor-link" aria-hidden="true"><span class="headeranchor"></span></a>五、例子源码</h3>
<p><a href="http://pan.baidu.com/s/1mh1fO4S">度盘</a></p>
		<!-- 多说评论框 start -->
		<div class="ds-thread" data-thread-key="660928631e1a89dbab8707aa2394e1e5" data-title="Android的aidl相互通信机制" data-url="http://blog.zeromake.com/pages/Android的aidl相互通信机制/">
		</div>
	<!-- 多说评论框 end -->
	</div>

		</div>
	</div>
</body>
</html>